#!/bin/bash
#
# Execute the sds/maskfill Docker image as a container. This script is designed
# to be an identical interface as maskfill.sh, and to not edit the contents of
# the MaskFill Python modules. To operate successfully, this script must:
#
# 1) Identify the output directory as defined in the host system.
# 2) Check the input file being masked. If it is not within the host output
#    directory, it needs to be placed there, to ensure the Docker container
#    can access it.
# 3) Check the bounding shape argument. If it is an existing file, and it is
#    not in the output directory, it must be copied there to ensure the Docker
#    container can access it.
# 4) Modify the call to MaskFill to list the output directory as a directory
#    within the container.
# 5) If the input for the BOUNDINGSHAPE is recognised as raw GeoJSON, this
#    is written out to a file in the host directory that will be used for the
#    mounted volume. The file path of this new shape file, with respect to its
#    location in the Docker container, will be used as the BOUNDINGSHAPE
#    argument when calling MaskFill via the `docker run` command. This
#    minimises the possibility of problems with character escaping in passing
#    the argument to `MaskFill.py` via `docker run`.
# 6) The arguments in the `docker run` command for FILE_URLS, OUTPUT_DIR and
#    BOUNDINGSHAPE (if it is a file path) must be modified to point to the
#    directory location within the Docker container, not the host file system.
# 7) The `docker run` command must specify a mounted volume, so the Docker
#    container can access the output directory in the host file system from
#    within the container.
#
# Outstanding work:
#
# 1) The message returned from the container needs to be intercepted from the
#    `docker run` command (without the full logging).
# 2) The message, once captured needs to be modified to replace container
#    directory references with host directory references. (e.g. replace
#    "/home/results" from the message).
#

# Remove Python bytecode files
find . | grep -E "(__pycache__|\.pyc|\.pyo$)" | xargs rm -rf

# Define the destination of a mounted volume:
CONTAINER_DIRECTORY="/home/results"
CONTAINER_OUTPUT_DIR_ARGUMENT="--OUTPUT_DIR ${CONTAINER_DIRECTORY}"

# Extract the OUTPUT_DIR
INPUT_STRING="$@"

# Identify the supplied output directory, and use it to define a mounted volume.
# The string arguments to MaskFill should also be updated.
#
OUTPUT_DIR_REGEXP="(--OUTPUT_DIR[[:space:]=]([^[:space:]]+))"

if [[ $INPUT_STRING =~ $OUTPUT_DIR_REGEXP ]]; then
	HOST_DIRECTORY_ARGUMENT=${BASH_REMATCH[1]}
	HOST_DIRECTORY=${BASH_REMATCH[2]}
	echo "Identified host directory: ${HOST_DIRECTORY}"
	OUTPUT_STRING=${INPUT_STRING/$HOST_DIRECTORY_ARGUMENT/$CONTAINER_OUTPUT_DIR_ARGUMENT}
else
	echo "Could not identify --OUTPUT_DIR"
	exit 1
fi

# Identify the supplied input file, and ensure it is in the host directory that
# will be accessible via a mounted volume.
#
FILE_URLS_REGEXP="(--FILE_URLS[[:space:]=]([^[:space:]]+))"

if [[ $OUTPUT_STRING =~ $FILE_URLS_REGEXP ]]; then
	FILE_URLS_ARGUMENT=${BASH_REMATCH[1]}
	HOST_INPUT_FILE=${BASH_REMATCH[2]}
	HOST_INPUT_FILE_BASENAME=$(basename $HOST_INPUT_FILE)
	HOST_INPUT_FILE_DIRNAME=$(dirname $HOST_INPUT_FILE)
	CONTAINER_INPUT_FILE="${CONTAINER_DIRECTORY}/${HOST_INPUT_FILE_BASENAME}"
	echo "Identified input file: ${INPUT_FILE}"

	# Copy file if it's not in the correct place
	if [[ $HOST_INPUT_FILE_DIRNAME != $HOST_DIRECTORY ]]; then
		cp $HOST_INPUT_FILE "${HOST_DIRECTORY}/${HOST_INPUT_FILE_BASENAME}"
	fi

	OUTPUT_STRING=${OUTPUT_STRING/$HOST_INPUT_FILE/$CONTAINER_INPUT_FILE}
else
	echo "Could not identify --FILE_URLS"
	exit 1
fi

# Identify the shape file input. If it is a file path, make sure it is present
# in the host directory that will be accessible via a mounted volume.
# 
SHAPE_FILE_REGEX="(--BOUNDINGSHAPE[[:space:]=]([^[:space:]]+))"
GEOJSON_REGEX="--BOUNDINGSHAPE[[:space:]=]\'({.+})\'"

if [[ $OUTPUT_STRING =~ $SHAPE_FILE_REGEX ]]; then
	BOUNDINGSHAPE_ARGUMENT=${BASH_REMATCH[1]}
	BOUNDINGSHAPE_PATH=${BASH_REMATCH[2]}

	if [[ -f $BOUNDINGSHAPE_PATH ]]; then
		echo "BOUNDINGSHAPE argument is a file path: ${BOUNDINGSHAPE_PATH}"
		BOUNDINGSHAPE_BASENAME=$(basename $BOUNDINGSHAPE_PATH)
		BOUNDINGSHAPE_DIRNAME=$(dirname $BOUNDINGSHAPE_PATH)

		if [[ $BOUNDINGSHAPE_DIRNAME != $HOST_DIRECTORY ]]; then
			HOST_SHAPEFILE="${HOST_DIRECTORY}/${BOUNDINGSHAPE_BASENAME}"
			CONTAINER_SHAPEFILE="${CONTAINER_DIRECTORY}/${BOUNDINGSHAPE_BASENAME}"
			cp $BOUNDINGSHAPE_PATH $HOST_SHAPEFILE
			echo "Shape file copied to ${HOST_DIRECTORY}"
			OUTPUT_STRING=${OUTPUT_STRING/$BOUNDINGSHAPE_PATH/$CONTAINER_SHAPEFILE}
		else
			echo "Shape file already in ${HOST_DIRECTORY}"
		fi
	else
		echo "BOUNDINGSHAPE is not a file, therefore assuming it is raw GeoJSON"
		echo "$OUTPUT_STRING"
		if [[ $OUTPUT_STRING =~ $GEOJSON_REGEX ]]; then
			BOUNDING_GEOJSON=${BASH_REMATCH[1]}
			HOST_SHAPEFILE="${HOST_DIRECTORY}/maskfill_shapefile.geo.json"
			CONTAINER_SHAPEFILE="${CONTAINER_DIRECTORY}/maskfill_shapefile.geo.json"
			echo $BOUNDING_GEOJSON > ${HOST_DIRECTORY}/maskfill_shapefile.geo.json
			OUTPUT_STRING=${OUTPUT_STRING/$BOUNDING_GEOJSON/$CONTAINER_SHAPEFILE}
			echo "Saved raw GeoJSON to ${HOST_SHAPEFILE}"
		else
			echo "Could not locate GeoJSON string"
			exit 1
		fi
	fi
else
	echo "Could not identify --BOUNDINGSHAPE"
	exit 1
fi

# Execute the saved Docker image as a container.
#
docker run --rm -it -v ${HOST_DIRECTORY}:${CONTAINER_DIRECTORY} sds/maskfill $OUTPUT_STRING
